<html><head><!-- <script src="three.js/Three.js"></script> --><script src="./js/three.min.js"></script><script src="./js/TrackballControls.js"></script><script src="./js/NURBSCurve.js"></script><script src="./js/NURBSUtils.js"></script><style type="text/css">body {	background: #ddd;	margin: 0px;	padding: 0px;}</style><title>NURBS Demo - Single curve segment</title></head><body><script>var container = document.createElement( 'div' );document.body.appendChild( container );var renderer = new THREE.WebGLRenderer({antialias: true});renderer.setSize(document.body.clientWidth, document.body.clientHeight);document.body.appendChild(renderer.domElement);var scene = new THREE.Scene();var width = renderer.domElement.width, height = renderer.domElement.height;var camera = new THREE.PerspectiveCamera( 45, width/height, 1, 10000 );camera.position.z = 50;scene.add(camera);var controls = new THREE.TrackballControls( camera );generate();function generate() {	sailGeometry = buildSail([		new THREE.Vector3(-10, -10, 0),		new THREE.Vector3(10, -10, 0),		new THREE.Vector3(0, 5, 0)	], 10, 20);	var sailMaterial = new THREE.MeshNormalMaterial({		side: THREE.DoubleSide,		wireframe: false,		smoothing: THREE.SmoothShading});	var sailMesh = new THREE.Mesh(sailGeometry, sailMaterial);	scene.add(sailMesh);}function buildSail(points, height, resolution) {	var centroid = new THREE.Vector3();	centroid.add(points[0]);	centroid.add(points[1]);	centroid.add(points[2]);	centroid.multiplyScalar(1 / 3);	var ab = points[1].clone().sub(points[0]);	var ac = points[2].clone().sub(points[0]);	var normal = ab.clone().cross(ac).normalize();	var offset = normal.clone().multiplyScalar(height);	var backbonePoints = [		points[0],		centroid.clone().add(offset),		points[1].clone().lerp(points[2], .5)	];	var n = resolution;	var backboneSpline = buildSpline(backbonePoints, n);	var splines = [];	for(var i = 0; i < n; i++) {		var t = i / (n - 1);		var a = points[0].clone().lerp(points[1], t);		var b = points[0].clone().lerp(points[2], t);		var controlPoints = [a, backboneSpline[i], b];		splines.push(buildSpline(controlPoints, n));	}	var curvedGeometry = new THREE.PlaneGeometry(1, 1, n - 1, n - 1);	for(var i = 0; i < n; i++) {		for(var j = 0; j < n; j++) {			var k = i * n + j;			curvedGeometry.vertices[k] = splines[i][j];		}	}	curvedGeometry.computeFaceNormals();	return curvedGeometry;}function buildSpline(points, n) {	var knots3 = [0,0,0,1,1,1]; //5 points, order 3, multiplicity = order	var order3 = 3; //order 3 = degree 2 = quadratic	var curve3 = new THREE.NURBSCurve ( points, knots3, order3 );	var bspline3 = THREE.NURBSCurveGeometry ( curve3, n );	return bspline3;}var clock = new THREE.Clock();function animate() {	requestAnimationFrame(animate);	controls.update(clock.getDelta());	renderer.render(scene, camera);}animate();</script></body></html>